var verbs = {
	go: {
		sigs: [ "go self", "go none in self", "go none at self", "go none through self" ],
		code: function() {
			function maze(xsize, ysize, punchpct) {
				// 8, 8, 3
				function rand(min, max) {
					return Math.floor(Math.random() * (max - min)) + min;
				}

				let grid = [];
				for (let y=0; y<ysize; ++y) {
					let r = [];
					grid.push(r);
					for (let x=0; x<xsize; ++x)
						r.push("#");
				}

				let checks = [ [-1, 0], [1, 0], [0, -1], [0, 1] ];

				function next(curx, cury, first) {
					// Unblock the current space.
					if (first)
						grid[cury][curx] = "+";
					else
						grid[cury][curx] = " ";

					// Pick a random direction that is not:
					// - Outside the map
					// - Behind an already opened wall.
					let dir = rand(0, 4);
					let dirarr = [];
					for (let i=0; i<4; ++i) {
						dirarr.push(dir);
						dir = (dir + 1) % 4;
					}
					for (let d of dirarr) {
						let vx = 0, vy = 0;
						switch (d) {
							case 0: // up
								vy = -1;
								break;
							case 1: // right
								vx = 1;
								break;
							case 2: // down
								vy = 1;
								break;
							case 3: // left
								vx = -1;
								break;
						}

						// Do the coordinates meet the requirements?
						let nx = curx + vx, ny = cury + vy;
						if (nx < 1 || ny < 1 || nx >= (xsize-1) || ny >= (ysize-1)) {
							if (nx === 0 || ny === 0 || nx === (xsize-1) || ny === (ysize-1)) {
								let makeExit = rand(0, 100);
								if (makeExit < 30) {
									// Look for nearby exits and don't put two next to each other.
									let skipExit = false;
									for (let check of checks) {
										let cx = nx + check[0];
										let cy = ny + check[1];
										if (cx >= 0 && cy >= 0 && cx <= (xsize-1) && cy <= (ysize-1))
											if (grid[cy][cx] === "+")
												skipExit = true;
									}
									if (!skipExit)
										grid[ny][nx] = "+";
								}
							}
							continue;
						}
						if (grid[ny][nx] === " ")
							continue;
						let borked = false;
						if (rand(0, 100) >= punchpct) {
							for (let check of checks) {
								let px = check[0];
								let py = check[1];
								if ( !((ny+py) === cury && (nx+px) === curx) && grid[ny+py][nx+px] === " ")
									borked = true;
							}
						}

						if (!borked)
							next(nx, ny);
					}
				}

				let x1 = 3;
				let y1 = 0;
				next(x1, y1, true);

				for (let y=0; y<ysize; ++y) {
					let o = "";
					for (let x=0; x<xsize; ++x) {
						o += grid[y][x];
					}
					$player.$hear([o]);
				}
			}

			maze(12, 12, 5);
		}
	}
};
